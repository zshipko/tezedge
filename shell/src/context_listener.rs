// Copyright (c) SimpleStaking and Tezedge Contributors
// SPDX-License-Identifier: MIT

//! Listens for events from the `protocol_runner`.

use std::{hash::Hash, sync::atomic::{AtomicBool, Ordering}};
use std::sync::{Arc, Mutex};
use std::thread;
use std::thread::JoinHandle;
use std::time::Duration;
use std::borrow::BorrowMut;
use std::io::{BufReader, Read, Seek, SeekFrom, Write};
use std::collections::HashSet;
use bytes::{Buf, BufMut, BytesMut};
use hex;

use failure::Error;
use riker::actors::*;
use slog::{crit, debug, info, error, warn, Logger};

use crypto::hash::HashType;
use storage::action_file_storage::ActionFileStorage;
use storage::context::{ContextApi, TezedgeContext};
use storage::persistent::PersistentStorage;
use storage::{BlockStorage, ContextActionStorage, ActionRecorder};
use tezos_context::channel::{ContextAction, ContextActionMessage};
use tezos_wrapper::service::IpcEvtServer;

type SharedJoinHandle = Arc<Mutex<Option<JoinHandle<Result<(), Error>>>>>;

/// This actor listens for events generated by the `protocol_runner`.
#[actor]
pub struct ContextListener {
    /// Thread where blocks are applied will run until this is set to `false`
    listener_run: Arc<AtomicBool>,
    /// Context event listener thread
    listener_thread: SharedJoinHandle,
}

/// Reference to [context listener](ContextListener) actor.
pub type ContextListenerRef = ActorRef<ContextListenerMsg>;

impl ContextListener {
    // TODO: if needed, can go to cfg
    const IPC_ACCEPT_TIMEOUT: Duration = Duration::from_secs(3);

    /// Create new actor instance.
    ///
    /// This actor spawns a new thread in which it listens for incoming events from the `protocol_runner`.
    /// Events are received from IPC channel provided by [`event_server`](IpcEvtServer).
    pub fn actor(
        sys: &impl ActorRefFactory,
        persistent_storage: &PersistentStorage,
        action_store_backend: Box<dyn ActionRecorder + Send>,
        mut event_server: IpcEvtServer,
        log: Logger,
    ) -> Result<ContextListenerRef, CreateError> {
        let listener_run = Arc::new(AtomicBool::new(true));
        let block_applier_thread = {
            let listener_run = listener_run.clone();
            let persistent_storage = persistent_storage.clone();

            thread::spawn(move || -> Result<(), Error> {
                let mut context: Box<dyn ContextApi> = Box::new(TezedgeContext::new(
                    BlockStorage::new(&persistent_storage),
                    persistent_storage.merkle(),
                ));

                let mut action_store_backend = action_store_backend;

                while listener_run.load(Ordering::Acquire) {
                    match listen_protocol_events(
                        &listener_run,
                        &mut event_server,
                        Self::IPC_ACCEPT_TIMEOUT,
                        &mut *action_store_backend ,
                        &mut context,
                        &log,
                    ) {
                        Ok(()) => info!(log, "Context listener finished"),
                        Err(err) => {
                            if listener_run.load(Ordering::Acquire) {
                                crit!(log, "Error process context event"; "reason" => format!("{:?}", err))
                            }
                        }
                    }
                }

                info!(log, "Context listener thread finished");
                Ok(())
            })
        };

        let myself = sys.actor_of_props::<ContextListener>(
            ContextListener::name(),
            Props::new_args((
                listener_run,
                Arc::new(Mutex::new(Some(block_applier_thread))),
            )),
        )?;

        Ok(myself)
    }

    /// The `ContextListener` is intended to serve as a singleton actor so that's why
    /// we won't support multiple names per instance.
    fn name() -> &'static str {
        "context-listener"
    }
}

impl ActorFactoryArgs<(Arc<AtomicBool>, SharedJoinHandle)> for ContextListener {
    fn create_args((listener_run, listener_thread): (Arc<AtomicBool>, SharedJoinHandle)) -> Self {
        ContextListener {
            listener_run,
            listener_thread,
        }
    }
}

impl Actor for ContextListener {
    type Msg = ContextListenerMsg;

    fn post_stop(&mut self) {
        self.listener_run.store(false, Ordering::Release);

        let _ = self
            .listener_thread
            .lock()
            .unwrap()
            .take()
            .expect("Thread join handle is missing")
            .join()
            .expect("Failed to join context listener thread");
    }

    fn recv(&mut self, ctx: &Context<Self::Msg>, msg: Self::Msg, sender: Sender) {
        self.receive(ctx, msg, sender);
    }
}

fn listen_protocol_events(
    apply_block_run: &AtomicBool,
    event_server: &mut IpcEvtServer,
    event_server_accept_timeout: Duration,
    action_store_backend: &mut dyn ActionRecorder,
    context: &mut Box<dyn ContextApi>,
    log: &Logger
) -> Result<(), Error> {
    info!(log, "Waiting for connection from protocol runner");
    let mut rx = event_server.try_accept(event_server_accept_timeout)?;
    info!(
        log,
        "Received connection from protocol runner. Starting to process context events."
    );

    let mut event_count = 0;
    let mut entries = HashSet::new();
    entries.insert("81e47a19e6b29b0a65b9591762ce5143ed30d0261e5d24a3201752506b20f15c".to_string());

    while apply_block_run.load(Ordering::Acquire) {
        match rx.receive() {


            Ok(ContextActionMessage {
                action: ContextAction::Shutdown,
                ..
            }) => {
                info!(
                    log,
                    "!!!!!!!!!!!!!! SHUTDOWN .!!!!!!!!!!!!!!!!!"
                );

                apply_block_run.store(false, Ordering::Release);
            }
            Ok(msg) => {
                if event_count % 100 == 0 {
                    debug!(
                        log,
                        "Received protocol event";
                        "count" => event_count,
                        "context_hash" => match &context.get_last_commit_hash() {
                            None => "-none-".to_string(),
                            Some(c) => HashType::ContextHash.hash_to_b58check(c)
                        }
                    );
                }



                info!(log, "!!!!!!!!!!!!!! MESSAGE RECEIVED .!!!!!!!!!!!!!!!!!");
                info!(log, "TREE_HASH: {}", hex::encode(get_tree_hash(&msg.action).or(Some([0_u8;32])).unwrap()));
                info!(log, "NEW_TREE_HASH: {}", hex::encode(get_new_tree_hash(&msg.action).or(Some([0_u8;32])).unwrap()));
                info!(log, "RECORD: {:?}", msg.record);
                info!(log, "MSG: {:?}", msg);


                if ! msg.record{
                    continue;
                }


                event_count = if let ContextAction::Shutdown = &msg.action {
                    0
                } else {
                    event_count + 1
                };

                if let Err(error) = action_store_backend.record(&msg){
                    error!(log,"action: {:?} ,error: {} ",&msg.action , error);
                    break;
                }

                if let Some(hash) = get_tree_hash(&msg.action){
                    if let None = entries.get(&hex::encode(&hash)){
                        panic!(format!("action {:?} requires to be executed on merkle tree that does not exists {}",&msg.action ,hex::encode(&hash)));
                    }
                }

                // let exptected_initial_tree_hash = get_tree_hash(&msg.action);
                // let exptected_final_tree_hash = get_new_tree_hash(&msg.action);
                // let actual_initial_tree_hash = context.get_merkle_hash();
                //
                // if let Some(hash) = exptected_initial_tree_hash{
                //     if hash != actual_initial_tree_hash{
                //         context.store_merkle_hash(hash);
                //         //error!(log, "PRECONDITION FAILED current: {} expected: {}", actual_initial_tree_hash, hash);
                //     }
                // }
                //

                if let Err(e) = perform_context_action(&msg.action, context){
                    error!(log, "error while processing action: {:?} reason  '{}'", &msg.action, e);
                    panic!("error while executing action");
                }

                if let Some(hash) = get_new_tree_hash(&msg.action){
                    assert_eq!(context.get_merkle_hash() , hash);
                    entries.insert(hex::encode(&hash));
                }

                // let actual_final_tree_hash = context.get_merkle_hash();
                // if let Some(hash) = exptected_final_tree_hash{
                //     if hash != actual_final_tree_hash{
                //         error!(log, "POSTCONDITION FAILED current: {} expected: {}", hex::encode(actual_final_tree_hash), hex::encode(hash));
                //     }
                // }
            }
            Err(err) => {
                warn!(log, "Failed to receive event from protocol runner"; "reason" => format!("{:?}", err));
                break;
            }
        }
    }

    Ok(())
}

// returns hash of the merkle tree that action needs to be
// applied on
pub fn get_tree_hash(action: &ContextAction) -> Option<[u8;32]> {
    match &action
    {
        ContextAction::Get {tree_hash, .. }
        | ContextAction::Mem {tree_hash, .. }
        | ContextAction::DirMem {tree_hash, ..}
        | ContextAction::Set {tree_hash, ..}
        | ContextAction::Copy {tree_hash, ..}
        | ContextAction::Delete {tree_hash, ..}
        | ContextAction::RemoveRecursively {tree_hash, ..}
        | ContextAction::Commit {tree_hash, ..}
        | ContextAction::Fold {tree_hash, ..} => {
            let mut hash:[u8;32] = [0;32];
            tree_hash.clone().reader().read_exact(& mut hash).unwrap();
            Some(hash)
        }
        _ => {None}
    }
}

pub fn get_new_tree_hash(action: &ContextAction) -> Option<[u8;32]> {
    match &action{
        ContextAction::Set {new_tree_hash, ..}
        | ContextAction::Copy {new_tree_hash, ..}
        | ContextAction::Delete {new_tree_hash, ..}
        | ContextAction::RemoveRecursively {new_tree_hash, ..} => {
            let mut hash:[u8;32] = [0;32];
            new_tree_hash.clone().reader().read_exact(& mut hash).unwrap();
            Some(hash)
        }
        _ => {None}
    }
}


pub fn perform_context_action(
    action: &ContextAction,
    context: &mut Box<dyn ContextApi>,
) -> Result<(), Error> {
    
    match action {
        ContextAction::Get { key,tree_hash, .. } => {
            context.get_key(key)?;
        }
        ContextAction::Mem { key, .. } => {
            context.mem(key)?;
        }
        ContextAction::DirMem { key, .. } => {
            context.dirmem(key)?;
        }
        ContextAction::Set {
            key,
            value,
            context_hash,
            ..
        } => {
            context.set(context_hash, key, value)?;
        }
        ContextAction::Copy {
            to_key: key,
            from_key,
            context_hash,
            ..
        } => {
            context.copy_to_diff(context_hash, from_key, key)?;
        }
        ContextAction::Delete {
            key, context_hash, ..
        } => {
            context.delete_to_diff(context_hash, key)?;
        }
        ContextAction::RemoveRecursively {
            key, context_hash, ..
        } => {
            context.remove_recursively_to_diff(context_hash, key)?;
        }
        ContextAction::Commit {
            parent_context_hash,
            new_context_hash,
            block_hash: Some(block_hash),
            author,
            message,
            date,
            ..
        } => {
            let hash_result = context.commit(
                block_hash,
                parent_context_hash,
                author.to_string(),
                message.to_string(),
                *date,
            );
            let hash = hash_result?;
            assert_eq!(
                &hash,
                new_context_hash,
                "Invalid context_hash for block: {}, expected: {}, but was: {}",
                HashType::BlockHash.hash_to_b58check(block_hash),
                HashType::ContextHash.hash_to_b58check(new_context_hash),
                HashType::ContextHash.hash_to_b58check(&hash),
            );
        }

        ContextAction::Checkout { context_hash, .. } => {
            context.checkout(context_hash)?;
        }

        ContextAction::Commit { .. } => (), // Ignored (no block_hash)

        ContextAction::Fold { .. } => (), // Ignored

        ContextAction::Shutdown => (), // Ignored
    };


    Ok(())
}
